{"version":3,"sources":["components/Header/index.js","components/InfiniteScroll/ScrollItem.js","components/LoadingSpinner/index.js","components/InfiniteScroll/index.js","utils/fetchGithubApi.js","utils/useFetchApi.js","constant.js","components/Main.js","App.jsx","index.jsx"],"names":["Header","history","useHistory","useParams","searchTerm","useState","typed","setTyped","searchState","setSearchState","useDebounce","debouncedSearchState","useEffect","push","className","type","placeholder","value","onChange","e","target","React","memo","ScrollItem","forwardRef","ref","itemData","href","full_name","rel","name","description","stargazers_count","language","license","LoadingSpinner","countDown","count","setCount","intervalId","setInterval","c","clearInterval","defaultProps","InfiniteScroll","dataList","fetchMore","hasMore","error","loading","observerRef","useRef","setObserver","useCallback","node","current","disconnect","IntersectionObserver","entries","isIntersecting","observe","map","data","id","GITHUB_API_DOMAIN","url","a","axios","method","Error","fetchGithubApi","useFetchApi","timer","setLoading","setData","page","setPage","setError","setHasMore","retrySeconds","setRetrySeconds","fetchData","variables","queryString","qs","stringify","q","per_page","addQueryPrefix","apiData","items","length","fetchApiFn","fetchedData","newDataList","uniqBy","item","p","fetchResetMs","rateData","resetTime","resources","search","reset","msLeft","Date","valueOf","parseInt","setTimeout","Main","fetchApi","App","basename","process","path","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.ead5619f.chunk.js","sourcesContent":["// @flow\n\nimport React, {\n  useState,\n  useEffect,\n} from 'react';\nimport {\n  useHistory,\n  useParams,\n} from 'react-router-dom';\nimport { useDebounce } from 'use-debounce';\n\nfunction Header() {\n  const history = useHistory();\n\n  const {\n    searchTerm = '',\n  } = useParams();\n\n  const [typed, setTyped] = useState(searchTerm || '');\n  const [searchState, setSearchState] = useState(searchTerm || '');\n  const [debouncedSearchState] = useDebounce(searchState, 500);\n\n  useEffect(() => {\n    history.push(`/${debouncedSearchState || ''}`);\n  }, [debouncedSearchState, history]);\n\n  useEffect(() => {\n    setTyped(searchTerm);\n  }, [searchTerm]);\n\n  return (\n    <div className=\"header\">\n      <input\n        type=\"text\"\n        className=\"header__search-input\"\n        placeholder=\"Input Search Words\"\n        value={typed}\n        onChange={(e) => {\n          setTyped(e.target.value || '');\n          setSearchState(e.target.value || '');\n        }} />\n    </div>\n  );\n}\n\nexport default React.memo(Header);\n","// @flow\n\nimport React from 'react';\n\nconst GITHUB_DOMAIN = 'https://github.com';\n\ntype Props = {\n  itemData: {\n    full_name?: String,\n    name?: String,\n    description?: String,\n    stargazers_count?: Number,\n    language?: String,\n    license?: {\n      name: String,\n    },\n  }\n}\n\nconst ScrollItem = React.forwardRef(({\n  itemData,\n}: Props, ref) => (\n  <div ref={ref} className=\"infinite-scroll__item\">\n    <a\n      className=\"infinite-scroll__item__link\"\n      href={`${GITHUB_DOMAIN}/${itemData.full_name}`}\n      target=\"_blank\"\n      rel=\"noreferrer\">\n      {itemData.name}\n    </a>\n    <span className=\"infinite-scroll__item__desc\">\n      {itemData.description}\n    </span>\n    <div className=\"infinite-scroll__item__remark-wrapper\">\n      <div className=\"infinite-scroll__item__remark\">\n        <i className=\"fa fa-star\" />\n        {' '}\n        {itemData?.stargazers_count}\n      </div>\n      <div className=\"infinite-scroll__item__remark\">\n        <div className=\"infinite-scroll__item__remark__circle-icon\" />\n        {itemData?.language}\n      </div>\n      <div className=\"infinite-scroll__item__remark\">\n        {itemData?.license?.name}\n      </div>\n    </div>\n  </div>\n));\n\nexport default ScrollItem;\n","// @flow\n\nimport React, {\n  useState,\n  useEffect,\n} from 'react';\nimport './index.scss';\n\ntype Props = {\n  countDown?: Number,\n};\n\nconst LoadingSpinner = ({\n  countDown,\n}: Props) => {\n  const [count, setCount] = useState(countDown);\n\n  useEffect(() => {\n    if (countDown) {\n      const intervalId = setInterval(() => {\n        setCount(c => c - 1);\n      }, 1000);\n\n      return () => {\n        clearInterval(intervalId);\n      };\n    }\n\n    return () => null;\n  }, [countDown]);\n\n  return (\n    <div className=\"loading-spinner-wrapper\">\n      <div className=\"loading-spinner\" />\n      {count ? (\n        <span className=\"loading-spinner__countdown\">{count}</span>\n      ) : null}\n    </div>\n  );\n};\n\nLoadingSpinner.defaultProps = {\n  countDown: 0,\n};\n\nexport default LoadingSpinner;\n","// @flow\n\nimport React, {\n  useRef,\n  useCallback,\n} from 'react';\nimport ScrollItem from './ScrollItem';\nimport LoadingSpinner from '../LoadingSpinner';\n\ntype Props = {\n  dataList: Array,\n  fetchMore: Function,\n  hasMore: Boolean,\n  error?: Object,\n  loading: Boolean,\n}\n\nfunction InfiniteScroll({\n  dataList,\n  fetchMore,\n  hasMore,\n  error,\n  loading,\n}: Props) {\n  const observerRef = useRef();\n\n  const setObserver = useCallback((node) => {\n    if (loading) {\n      return;\n    }\n\n    if (observerRef.current) {\n      observerRef.current.disconnect();\n    }\n\n    observerRef.current = new IntersectionObserver((entries) => {\n      if (entries[0].isIntersecting && hasMore && !error) {\n        fetchMore();\n      }\n    });\n\n    if (node) {\n      observerRef.current.observe(node);\n    }\n  }, [error, fetchMore, hasMore, loading]);\n\n  return (\n    <div className=\"infinite-scroll\">\n      {dataList.map(data => (\n        <ScrollItem\n          key={data.id}\n          itemData={data} />\n      ))}\n      <div className=\"observer\" ref={setObserver} />\n      {loading ? (\n        <LoadingSpinner />\n      ) : null}\n    </div>\n  );\n}\n\nInfiniteScroll.defaultProps = {\n  error: null,\n};\n\nexport default React.memo(InfiniteScroll);\n","\nimport axios from 'axios';\n\nconst GITHUB_API_DOMAIN = 'https://api.github.com';\n\nasync function fetchGithubApi(url) {\n  try {\n    const { data } = await axios({\n      method: 'GET',\n      url: `${GITHUB_API_DOMAIN}${url}`,\n    });\n\n    return data;\n  } catch (e) {\n    throw new Error('API Failed');\n  }\n}\n\nexport default fetchGithubApi;\n","import {\n  useRef,\n  useState,\n  useEffect,\n  useCallback,\n} from 'react';\nimport qs from 'qs';\nimport uniqBy from 'lodash/uniqBy';\nimport {\n  FETCH_LIMIT,\n  FETCH_RATE_LIMITS,\n} from '../constant';\nimport fetchGithubApi from './fetchGithubApi';\n\nfunction useFetchApi(url, searchTerm) {\n  const timer = useRef();\n  const [loading, setLoading] = useState(false);\n  const [data, setData] = useState([]);\n  const [page, setPage] = useState(0);\n  const [error, setError] = useState(null);\n  const [hasMore, setHasMore] = useState(true);\n  const [retrySeconds, setRetrySeconds] = useState(null);\n\n  const fetchData = useCallback(async (variables) => {\n    try {\n      const queryString = qs.stringify({\n        q: searchTerm,\n        per_page: FETCH_LIMIT,\n        ...variables,\n      }, {\n        addQueryPrefix: true,\n      });\n\n      const apiData = await fetchGithubApi(`${url}${queryString}`);\n\n      if (apiData.items.length < FETCH_LIMIT) {\n        setHasMore(false);\n      } else {\n        setHasMore(true);\n      }\n\n      return apiData;\n    } catch (e) {\n      setError(e);\n\n      return null;\n    }\n  }, [searchTerm, url]);\n\n  const fetchApiFn = useCallback(async () => {\n    setError(null);\n    setData([]);\n    setHasMore(true);\n\n    if (!searchTerm) return;\n\n    setLoading(true);\n\n    const fetchedData = await fetchData({\n      page: 1,\n    });\n\n    if (fetchedData) {\n      setData(fetchedData.items);\n\n      setPage(1);\n    }\n\n    setLoading(false);\n  }, [fetchData, searchTerm]);\n\n  const fetchMore = useCallback(async () => {\n    if (!hasMore) return;\n\n    setError(null);\n\n    setLoading(true);\n\n    const fetchedData = await fetchData({\n      page: page + 1,\n    });\n\n    if (fetchedData) {\n      if (fetchedData.items.length) {\n        const newDataList = uniqBy([\n          ...data,\n          ...fetchedData.items,\n        ], item => item.id);\n\n        if (newDataList.length !== data.length) {\n          setData(newDataList);\n\n          setPage(p => p + 1);\n        }\n      }\n    }\n\n    setLoading(false);\n  }, [data, fetchData, hasMore, page]);\n\n  const fetchResetMs = useCallback(async () => {\n    const rateData = await fetchGithubApi(FETCH_RATE_LIMITS);\n\n    if (rateData) {\n      const resetTime = rateData.resources.search.reset;\n\n      const msLeft = (resetTime * 1000) - new Date().valueOf() + 1000;\n\n      setRetrySeconds(parseInt(msLeft / 1000, 10));\n\n      timer.current = setTimeout(() => {\n        setError(null);\n        setRetrySeconds(null);\n      }, msLeft);\n    } else {\n      setRetrySeconds(60);\n\n      timer.current = setTimeout(() => {\n        setError(null);\n        setRetrySeconds(null);\n      }, 60000);\n    }\n  }, []);\n\n  useEffect(() => {\n    if (error) {\n      fetchResetMs();\n    }\n\n    return () => {\n      timer.current = null;\n    };\n  }, [error, fetchResetMs]);\n\n  return [fetchApiFn, {\n    data, loading, error, hasMore, fetchMore, retrySeconds,\n  }];\n}\n\nexport default useFetchApi;\n","export const FETCH_SEARCH_REPOS = '/search/repositories';\nexport const FETCH_RATE_LIMITS = '/rate_limit';\n\nexport const FETCH_LIMIT = 30;\n","// @flow\n\nimport React, {\n  useEffect,\n} from 'react';\nimport {\n  useParams,\n} from 'react-router-dom';\nimport Header from './Header';\nimport InfiniteScroll from './InfiniteScroll';\nimport LoadingSpinner from './LoadingSpinner';\nimport {\n  FETCH_SEARCH_REPOS,\n} from '../constant';\nimport useFetchApi from '../utils/useFetchApi';\nimport './main.scss';\n\nfunction Main() {\n  const {\n    searchTerm,\n  } = useParams();\n\n  const [fetchApi, {\n    data,\n    loading,\n    error,\n    hasMore,\n    fetchMore,\n    retrySeconds,\n  }] = useFetchApi(FETCH_SEARCH_REPOS, searchTerm);\n\n  useEffect(() => {\n    fetchApi();\n  }, [fetchApi]);\n\n  return (\n    <main className=\"main\">\n      <Header />\n      {searchTerm && (\n        <InfiniteScroll\n          dataList={data}\n          fetchMore={fetchMore}\n          hasMore={hasMore}\n          error={error}\n          loading={loading} />\n      )}\n      {error && retrySeconds ? (\n        <div className=\"placeholder\">\n          API limit is up, plz wait\n          <LoadingSpinner countDown={retrySeconds} />\n        </div>\n      ) : null}\n      {!hasMore ? (\n        <p className=\"placeholder\">\n          No more data\n        </p>\n      ) : null}\n    </main>\n  );\n}\n\nexport default Main;\n","import React from 'react';\nimport {\n  BrowserRouter,\n  Route,\n  Switch,\n} from 'react-router-dom';\nimport Main from './components/Main';\n\nfunction App() {\n  return (\n    <BrowserRouter basename={process.env.PUBLIC_URL}>\n      <Switch>\n        <Route path=\"/:searchTerm\">\n          <Main />\n        </Route>\n        <Route>\n          <Main />\n        </Route>\n      </Switch>\n    </BrowserRouter>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport './global.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n"],"sourceRoot":""}